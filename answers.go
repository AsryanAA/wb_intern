// 1. Какой самый эффективный способ конкатенации строк?

package main

import (
	"fmt"
	"strings"
)

func main() {
	// Создаем срез строк
	slice := []string{"Hello", " ", "World", "!"}

	// Конкатенируем строки
	result := strings.Join(slice, "")

	// Выводим результат
	fmt.Println(result)
}

package main

import "fmt"

func main() {
	str1 := "Hello"
	str2 := "World"
	str3 := "!"

	result := str1 + " " + str2 + str3

	fmt.Println(result)
}

// 2. Что такое интерфейсы, как они применяются в Go?

/*
	Интерфейсы в языке программирования Go представляют собой набор методов. Они определяют набор поведений, которые могут быть реализованы любым типом данных.
	Интерфейсы позволяют абстрагировать конкретные типы данных и работать с объектами, не зная их конкретных типов.
	В Go, тип данных автоматически удовлетворяет интерфейсу, если он реализует все методы, определенные в этом интерфейсе.
	Поэтому в Go нет явного объявления того, что тип реализует определенный интерфейс, как это делается в некоторых других языках программирования.
	Применение интерфейсов в Go включает в себя следующие аспекты:
	Абстрагирование: Интерфейсы позволяют абстрагировать конкретные типы данных. Это означает, что вы можете создавать функции и методы, которые работают с
	интерфейсами вместо конкретных типов данных. Например, вы можете создать функцию, которая принимает интерфейс io.Reader, и использовать ее
	для чтения данных из различных источников, таких как файлы, сетевые соединения и т. д., не зная конкретный тип каждого источника данных.
	Полиморфизм: Использование интерфейсов позволяет достичь полиморфизма в Go. Полиморфизм позволяет одному методу работать с разными типами данных.
	Например, метод Draw может рисовать различные фигуры,
	такие как круги, квадраты и треугольники, благодаря использованию интерфейса Shape.
	Реализация: В Go нет явного указания того, что тип реализует определенный интерфейс. Любой тип, который реализует все методы, определенные в интерфейсе,
	автоматически удовлетворяет этому интерфейсу. Это позволяет использовать уже существующие типы данных и добавлять к ним новое поведение, не изменяя их исходный код
*/

package main

import (
	"fmt"
	"math"
)

// Определяем интерфейс для геометрических фигур
type Shape interface {
	Area() float64
}

// Определяем структуру круга
type Circle struct {
	Radius float64
}

// Реализуем метод Area для круга
func (c Circle) Area() float64 {
	return math.Pi * c.Radius * c.Radius
}

// Функция, принимающая объекты, удовлетворяющие интерфейсу Shape
func printArea(s Shape) {
	fmt.Println("Площадь фигуры:", s.Area())
}

func main() {
	// Создаем объекты круга и прямоугольника
	circle := Circle{Radius: 5}
	
	// Вызываем функцию с объектами, удовлетворяющими интерфейсу Shape
	printArea(circle)
}

// 3. Чем отличаются RWMutex от Mutex?

Mutex Lock() UnLock()
RWMutex RLock() Lock()

// 4. Чем отличаются буферизированные и не буферизированные каналы?

/*
Не буферизованные каналы:
	Когда вы создаете канал без указания емкости (например, ch := make(chan int)), вы получаете не буферизованный канал.
	При отправке значения в не буферизованный канал (например, ch <- value), отправитель заблокируется до тех пор, 
	пока получатель не получит значение из канала.
	При получении значения из не буферизованного канала (например, value := <-ch), получатель также заблокируется до тех пор,
	пока отправитель не отправит значение.
Буферизованные каналы:
	Когда вы создаете канал с указанием емкости (например, ch := make(chan int, 5)), вы получаете буферизованный канал.
	Буферизованный канал имеет фиксированную емкость, что позволяет буферизировать (хранить временно) определенное количество значений в канале.
	При отправке значения в буферизованный канал, отправитель не блокируется до тех пор, пока канал не заполнится до максимальной емкости.
	Однако, если канал заполнен, отправитель заблокируется до тех пор, пока другая горутина не получит значение из канала и освободит
	место в буфере. При получении значения из буферизованного канала, получатель не блокируется до тех пор, пока
	в канале не будет доступно значение, если канал не пустой. Однако, если канал пуст, получатель будет заблокирован
	до тех пор, пока другая горутина не отправит значение в канал.
*/

// 5. Какой размер у структуры struct{}{}?
// пустая структура ничего не ве

// 6. Есть ли в Go перегрузка методов или операторов?
// В языке программирования Go нет поддержки перегрузки методов или операторов, как это сделано, например, в языках Java или C++

// 7. В какой последовательности будут выведены элементы map[int]int?
// Последовательность вывода элементов из map в Go не гарантирована

// 8. В чем разница make и new?
// make используется для создания экземпляров срезов, карт и каналов (ссылочные типы)
// new используется для создания экземпляров любых типов данных (не только ссылочных), возвращая указатель на ноль инициализированное значение указанного типа

// 9. Сколько существует способов задать переменную типа slice или map?
/*
	slice
		s := []int{1, 2, 3, 4, 5}

		s := make([]int, 5) // Создание среза длины 5

		arr := [5]int{1, 2, 3, 4, 5}
		s := arr[:] // Создание среза на основе массива arr

		arr := []int{1, 2, 3, 4, 5}
		s := arr[:] // Создание среза на основе существующего среза arr
	
	map
		m := map[string]int{"a": 1, "b": 2, "c": 3}

		m := make(map[string]int)

		m := make(map[string]int, 10) // Создание карты с начальной емкостью 10

		originalMap := map[string]int{"a": 1, "b": 2, "c": 3}
		m := originalMap // Создание карты на основе существующей карты originalMap
*/

// 10. 1 1
/*
	Причина в том, что функция update принимает указатель на int, и когда мы вызываем update(p) из main(),
	мы передаем указатель p на переменную a. Внутри функции update, мы создаем новую переменную b и
	изменяем значение указателя p на указатель на b, но это не изменяет значение a в main().
	Таким образом, при выводе *p после вызова update(p), мы все еще получаем первоначальное значение 1, хранящееся в a.
*/

// 11. deadlock all gorutines are sleep

/*
	Программа, как она написана сейчас, вызовет ошибку компиляции. Проблема заключается в том, что вы передаете
	sync.WaitGroup в анонимную функцию как значение, а не как указатель. Из-за этого каждая горутина будет работать
	с копией sync.WaitGroup, а не с оригинальным экземпляром, что может вызвать неопределенное поведение.

	Чтобы исправить это, вы должны передать sync.WaitGroup как указатель Либо вообще не передавать
*/

// 12. 0 Так как мы заново создаем переменную

// 13. {100, 2, 3, 4, 5}

// 14. [b, b, a] [a, a] 